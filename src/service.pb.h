// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef PROTOBUF_INCLUDED_service_2eproto
#define PROTOBUF_INCLUDED_service_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_service_2eproto 

namespace protobuf_service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_service_2eproto
namespace chirp {
class Chirp;
class ChirpDefaultTypeInternal;
extern ChirpDefaultTypeInternal _Chirp_default_instance_;
class ChirpReply;
class ChirpReplyDefaultTypeInternal;
extern ChirpReplyDefaultTypeInternal _ChirpReply_default_instance_;
class ChirpRequest;
class ChirpRequestDefaultTypeInternal;
extern ChirpRequestDefaultTypeInternal _ChirpRequest_default_instance_;
class FollowReply;
class FollowReplyDefaultTypeInternal;
extern FollowReplyDefaultTypeInternal _FollowReply_default_instance_;
class FollowRequest;
class FollowRequestDefaultTypeInternal;
extern FollowRequestDefaultTypeInternal _FollowRequest_default_instance_;
class MonitorReply;
class MonitorReplyDefaultTypeInternal;
extern MonitorReplyDefaultTypeInternal _MonitorReply_default_instance_;
class MonitorRequest;
class MonitorRequestDefaultTypeInternal;
extern MonitorRequestDefaultTypeInternal _MonitorRequest_default_instance_;
class ReadReply;
class ReadReplyDefaultTypeInternal;
extern ReadReplyDefaultTypeInternal _ReadReply_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class RegisterReply;
class RegisterReplyDefaultTypeInternal;
extern RegisterReplyDefaultTypeInternal _RegisterReply_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class StreamReply;
class StreamReplyDefaultTypeInternal;
extern StreamReplyDefaultTypeInternal _StreamReply_default_instance_;
class StreamRequest;
class StreamRequestDefaultTypeInternal;
extern StreamRequestDefaultTypeInternal _StreamRequest_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace chirp
namespace google {
namespace protobuf {
template<> ::chirp::Chirp* Arena::CreateMaybeMessage<::chirp::Chirp>(Arena*);
template<> ::chirp::ChirpReply* Arena::CreateMaybeMessage<::chirp::ChirpReply>(Arena*);
template<> ::chirp::ChirpRequest* Arena::CreateMaybeMessage<::chirp::ChirpRequest>(Arena*);
template<> ::chirp::FollowReply* Arena::CreateMaybeMessage<::chirp::FollowReply>(Arena*);
template<> ::chirp::FollowRequest* Arena::CreateMaybeMessage<::chirp::FollowRequest>(Arena*);
template<> ::chirp::MonitorReply* Arena::CreateMaybeMessage<::chirp::MonitorReply>(Arena*);
template<> ::chirp::MonitorRequest* Arena::CreateMaybeMessage<::chirp::MonitorRequest>(Arena*);
template<> ::chirp::ReadReply* Arena::CreateMaybeMessage<::chirp::ReadReply>(Arena*);
template<> ::chirp::ReadRequest* Arena::CreateMaybeMessage<::chirp::ReadRequest>(Arena*);
template<> ::chirp::RegisterReply* Arena::CreateMaybeMessage<::chirp::RegisterReply>(Arena*);
template<> ::chirp::RegisterRequest* Arena::CreateMaybeMessage<::chirp::RegisterRequest>(Arena*);
template<> ::chirp::StreamReply* Arena::CreateMaybeMessage<::chirp::StreamReply>(Arena*);
template<> ::chirp::StreamRequest* Arena::CreateMaybeMessage<::chirp::StreamRequest>(Arena*);
template<> ::chirp::Timestamp* Arena::CreateMaybeMessage<::chirp::Timestamp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chirp {

// ===================================================================

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(NULL);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // int64 useconds = 2;
  void clear_useconds();
  static const int kUsecondsFieldNumber = 2;
  ::google::protobuf::int64 useconds() const;
  void set_useconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:chirp.Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int64 useconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chirp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.Chirp) */ {
 public:
  Chirp();
  virtual ~Chirp();

  Chirp(const Chirp& from);

  inline Chirp& operator=(const Chirp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chirp(Chirp&& from) noexcept
    : Chirp() {
    *this = ::std::move(from);
  }

  inline Chirp& operator=(Chirp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chirp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chirp* internal_default_instance() {
    return reinterpret_cast<const Chirp*>(
               &_Chirp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Chirp* other);
  friend void swap(Chirp& a, Chirp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chirp* New() const final {
    return CreateMaybeMessage<Chirp>(NULL);
  }

  Chirp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chirp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chirp& from);
  void MergeFrom(const Chirp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chirp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // bytes id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes parent_id = 4;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_id(::std::string&& value);
  #endif
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  // .chirp.Timestamp timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  private:
  const ::chirp::Timestamp& _internal_timestamp() const;
  public:
  const ::chirp::Timestamp& timestamp() const;
  ::chirp::Timestamp* release_timestamp();
  ::chirp::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::chirp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:chirp.Chirp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  ::chirp::Timestamp* timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(NULL);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chirp.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.RegisterReply) */ {
 public:
  RegisterReply();
  virtual ~RegisterReply();

  RegisterReply(const RegisterReply& from);

  inline RegisterReply& operator=(const RegisterReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterReply(RegisterReply&& from) noexcept
    : RegisterReply() {
    *this = ::std::move(from);
  }

  inline RegisterReply& operator=(RegisterReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterReply* internal_default_instance() {
    return reinterpret_cast<const RegisterReply*>(
               &_RegisterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RegisterReply* other);
  friend void swap(RegisterReply& a, RegisterReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterReply* New() const final {
    return CreateMaybeMessage<RegisterReply>(NULL);
  }

  RegisterReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterReply& from);
  void MergeFrom(const RegisterReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.RegisterReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChirpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ChirpRequest) */ {
 public:
  ChirpRequest();
  virtual ~ChirpRequest();

  ChirpRequest(const ChirpRequest& from);

  inline ChirpRequest& operator=(const ChirpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChirpRequest(ChirpRequest&& from) noexcept
    : ChirpRequest() {
    *this = ::std::move(from);
  }

  inline ChirpRequest& operator=(ChirpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChirpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChirpRequest* internal_default_instance() {
    return reinterpret_cast<const ChirpRequest*>(
               &_ChirpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ChirpRequest* other);
  friend void swap(ChirpRequest& a, ChirpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChirpRequest* New() const final {
    return CreateMaybeMessage<ChirpRequest>(NULL);
  }

  ChirpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChirpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChirpRequest& from);
  void MergeFrom(const ChirpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChirpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // bytes parent_id = 3;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_id(::std::string&& value);
  #endif
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  // @@protoc_insertion_point(class_scope:chirp.ChirpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChirpReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ChirpReply) */ {
 public:
  ChirpReply();
  virtual ~ChirpReply();

  ChirpReply(const ChirpReply& from);

  inline ChirpReply& operator=(const ChirpReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChirpReply(ChirpReply&& from) noexcept
    : ChirpReply() {
    *this = ::std::move(from);
  }

  inline ChirpReply& operator=(ChirpReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChirpReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChirpReply* internal_default_instance() {
    return reinterpret_cast<const ChirpReply*>(
               &_ChirpReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ChirpReply* other);
  friend void swap(ChirpReply& a, ChirpReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChirpReply* New() const final {
    return CreateMaybeMessage<ChirpReply>(NULL);
  }

  ChirpReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChirpReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChirpReply& from);
  void MergeFrom(const ChirpReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChirpReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chirp.Chirp chirp = 1;
  bool has_chirp() const;
  void clear_chirp();
  static const int kChirpFieldNumber = 1;
  private:
  const ::chirp::Chirp& _internal_chirp() const;
  public:
  const ::chirp::Chirp& chirp() const;
  ::chirp::Chirp* release_chirp();
  ::chirp::Chirp* mutable_chirp();
  void set_allocated_chirp(::chirp::Chirp* chirp);

  // @@protoc_insertion_point(class_scope:chirp.ChirpReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chirp::Chirp* chirp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.FollowRequest) */ {
 public:
  FollowRequest();
  virtual ~FollowRequest();

  FollowRequest(const FollowRequest& from);

  inline FollowRequest& operator=(const FollowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowRequest(FollowRequest&& from) noexcept
    : FollowRequest() {
    *this = ::std::move(from);
  }

  inline FollowRequest& operator=(FollowRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowRequest* internal_default_instance() {
    return reinterpret_cast<const FollowRequest*>(
               &_FollowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FollowRequest* other);
  friend void swap(FollowRequest& a, FollowRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowRequest* New() const final {
    return CreateMaybeMessage<FollowRequest>(NULL);
  }

  FollowRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowRequest& from);
  void MergeFrom(const FollowRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string to_follow = 2;
  void clear_to_follow();
  static const int kToFollowFieldNumber = 2;
  const ::std::string& to_follow() const;
  void set_to_follow(const ::std::string& value);
  #if LANG_CXX11
  void set_to_follow(::std::string&& value);
  #endif
  void set_to_follow(const char* value);
  void set_to_follow(const char* value, size_t size);
  ::std::string* mutable_to_follow();
  ::std::string* release_to_follow();
  void set_allocated_to_follow(::std::string* to_follow);

  // @@protoc_insertion_point(class_scope:chirp.FollowRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr to_follow_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.FollowReply) */ {
 public:
  FollowReply();
  virtual ~FollowReply();

  FollowReply(const FollowReply& from);

  inline FollowReply& operator=(const FollowReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowReply(FollowReply&& from) noexcept
    : FollowReply() {
    *this = ::std::move(from);
  }

  inline FollowReply& operator=(FollowReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowReply* internal_default_instance() {
    return reinterpret_cast<const FollowReply*>(
               &_FollowReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FollowReply* other);
  friend void swap(FollowReply& a, FollowReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowReply* New() const final {
    return CreateMaybeMessage<FollowReply>(NULL);
  }

  FollowReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowReply& from);
  void MergeFrom(const FollowReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.FollowReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ReadRequest) */ {
 public:
  ReadRequest();
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReadRequest* other);
  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return CreateMaybeMessage<ReadRequest>(NULL);
  }

  ReadRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes chirp_id = 1;
  void clear_chirp_id();
  static const int kChirpIdFieldNumber = 1;
  const ::std::string& chirp_id() const;
  void set_chirp_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chirp_id(::std::string&& value);
  #endif
  void set_chirp_id(const char* value);
  void set_chirp_id(const void* value, size_t size);
  ::std::string* mutable_chirp_id();
  ::std::string* release_chirp_id();
  void set_allocated_chirp_id(::std::string* chirp_id);

  // @@protoc_insertion_point(class_scope:chirp.ReadRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chirp_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ReadReply) */ {
 public:
  ReadReply();
  virtual ~ReadReply();

  ReadReply(const ReadReply& from);

  inline ReadReply& operator=(const ReadReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadReply(ReadReply&& from) noexcept
    : ReadReply() {
    *this = ::std::move(from);
  }

  inline ReadReply& operator=(ReadReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadReply* internal_default_instance() {
    return reinterpret_cast<const ReadReply*>(
               &_ReadReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ReadReply* other);
  friend void swap(ReadReply& a, ReadReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadReply* New() const final {
    return CreateMaybeMessage<ReadReply>(NULL);
  }

  ReadReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadReply& from);
  void MergeFrom(const ReadReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chirp.Chirp chirps = 1;
  int chirps_size() const;
  void clear_chirps();
  static const int kChirpsFieldNumber = 1;
  ::chirp::Chirp* mutable_chirps(int index);
  ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >*
      mutable_chirps();
  const ::chirp::Chirp& chirps(int index) const;
  ::chirp::Chirp* add_chirps();
  const ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >&
      chirps() const;

  // @@protoc_insertion_point(class_scope:chirp.ReadReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::chirp::Chirp > chirps_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonitorRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.MonitorRequest) */ {
 public:
  MonitorRequest();
  virtual ~MonitorRequest();

  MonitorRequest(const MonitorRequest& from);

  inline MonitorRequest& operator=(const MonitorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonitorRequest(MonitorRequest&& from) noexcept
    : MonitorRequest() {
    *this = ::std::move(from);
  }

  inline MonitorRequest& operator=(MonitorRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorRequest* internal_default_instance() {
    return reinterpret_cast<const MonitorRequest*>(
               &_MonitorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(MonitorRequest* other);
  friend void swap(MonitorRequest& a, MonitorRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonitorRequest* New() const final {
    return CreateMaybeMessage<MonitorRequest>(NULL);
  }

  MonitorRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonitorRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonitorRequest& from);
  void MergeFrom(const MonitorRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chirp.MonitorRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonitorReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.MonitorReply) */ {
 public:
  MonitorReply();
  virtual ~MonitorReply();

  MonitorReply(const MonitorReply& from);

  inline MonitorReply& operator=(const MonitorReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonitorReply(MonitorReply&& from) noexcept
    : MonitorReply() {
    *this = ::std::move(from);
  }

  inline MonitorReply& operator=(MonitorReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorReply* internal_default_instance() {
    return reinterpret_cast<const MonitorReply*>(
               &_MonitorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MonitorReply* other);
  friend void swap(MonitorReply& a, MonitorReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonitorReply* New() const final {
    return CreateMaybeMessage<MonitorReply>(NULL);
  }

  MonitorReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonitorReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonitorReply& from);
  void MergeFrom(const MonitorReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chirp.Chirp chirp = 1;
  bool has_chirp() const;
  void clear_chirp();
  static const int kChirpFieldNumber = 1;
  private:
  const ::chirp::Chirp& _internal_chirp() const;
  public:
  const ::chirp::Chirp& chirp() const;
  ::chirp::Chirp* release_chirp();
  ::chirp::Chirp* mutable_chirp();
  void set_allocated_chirp(::chirp::Chirp* chirp);

  // @@protoc_insertion_point(class_scope:chirp.MonitorReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chirp::Chirp* chirp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.StreamRequest) */ {
 public:
  StreamRequest();
  virtual ~StreamRequest();

  StreamRequest(const StreamRequest& from);

  inline StreamRequest& operator=(const StreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamRequest(StreamRequest&& from) noexcept
    : StreamRequest() {
    *this = ::std::move(from);
  }

  inline StreamRequest& operator=(StreamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamRequest* internal_default_instance() {
    return reinterpret_cast<const StreamRequest*>(
               &_StreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(StreamRequest* other);
  friend void swap(StreamRequest& a, StreamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamRequest* New() const final {
    return CreateMaybeMessage<StreamRequest>(NULL);
  }

  StreamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamRequest& from);
  void MergeFrom(const StreamRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:chirp.StreamRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StreamReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.StreamReply) */ {
 public:
  StreamReply();
  virtual ~StreamReply();

  StreamReply(const StreamReply& from);

  inline StreamReply& operator=(const StreamReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamReply(StreamReply&& from) noexcept
    : StreamReply() {
    *this = ::std::move(from);
  }

  inline StreamReply& operator=(StreamReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamReply* internal_default_instance() {
    return reinterpret_cast<const StreamReply*>(
               &_StreamReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StreamReply* other);
  friend void swap(StreamReply& a, StreamReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamReply* New() const final {
    return CreateMaybeMessage<StreamReply>(NULL);
  }

  StreamReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StreamReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StreamReply& from);
  void MergeFrom(const StreamReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chirp.Chirp chirp = 1;
  bool has_chirp() const;
  void clear_chirp();
  static const int kChirpFieldNumber = 1;
  private:
  const ::chirp::Chirp& _internal_chirp() const;
  public:
  const ::chirp::Chirp& chirp() const;
  ::chirp::Chirp* release_chirp();
  ::chirp::Chirp* mutable_chirp();
  void set_allocated_chirp(::chirp::Chirp* chirp);

  // @@protoc_insertion_point(class_scope:chirp.StreamReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chirp::Chirp* chirp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:chirp.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:chirp.Timestamp.seconds)
}

// int64 useconds = 2;
inline void Timestamp::clear_useconds() {
  useconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::useconds() const {
  // @@protoc_insertion_point(field_get:chirp.Timestamp.useconds)
  return useconds_;
}
inline void Timestamp::set_useconds(::google::protobuf::int64 value) {
  
  useconds_ = value;
  // @@protoc_insertion_point(field_set:chirp.Timestamp.useconds)
}

// -------------------------------------------------------------------

// Chirp

// string username = 1;
inline void Chirp::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::username() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.username)
  return username_.GetNoArena();
}
inline void Chirp::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.username)
}
#if LANG_CXX11
inline void Chirp::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.username)
}
#endif
inline void Chirp::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.username)
}
inline void Chirp::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.username)
}
inline ::std::string* Chirp::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_username() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.username)
}

// string text = 2;
inline void Chirp::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::text() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.text)
  return text_.GetNoArena();
}
inline void Chirp::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.text)
}
#if LANG_CXX11
inline void Chirp::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.text)
}
#endif
inline void Chirp::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.text)
}
inline void Chirp::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.text)
}
inline ::std::string* Chirp::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_text() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.text)
}

// bytes id = 3;
inline void Chirp::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::id() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.id)
  return id_.GetNoArena();
}
inline void Chirp::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.id)
}
#if LANG_CXX11
inline void Chirp::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.id)
}
#endif
inline void Chirp::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.id)
}
inline void Chirp::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.id)
}
inline ::std::string* Chirp::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_id() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.id)
}

// bytes parent_id = 4;
inline void Chirp::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::parent_id() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.parent_id)
  return parent_id_.GetNoArena();
}
inline void Chirp::set_parent_id(const ::std::string& value) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.parent_id)
}
#if LANG_CXX11
inline void Chirp::set_parent_id(::std::string&& value) {
  
  parent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.parent_id)
}
#endif
inline void Chirp::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.parent_id)
}
inline void Chirp::set_parent_id(const void* value, size_t size) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.parent_id)
}
inline ::std::string* Chirp::mutable_parent_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_parent_id() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.parent_id)
  
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    
  } else {
    
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.parent_id)
}

// .chirp.Timestamp timestamp = 5;
inline bool Chirp::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void Chirp::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
}
inline const ::chirp::Timestamp& Chirp::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::chirp::Timestamp& Chirp::timestamp() const {
  const ::chirp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:chirp.Chirp.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Timestamp*>(
      &::chirp::_Timestamp_default_instance_);
}
inline ::chirp::Timestamp* Chirp::release_timestamp() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.timestamp)
  
  ::chirp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::chirp::Timestamp* Chirp::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.timestamp)
  return timestamp_;
}
inline void Chirp::set_allocated_timestamp(::chirp::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timestamp_;
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.timestamp)
}

// -------------------------------------------------------------------

// RegisterRequest

// string username = 1;
inline void RegisterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.RegisterRequest.username)
  return username_.GetNoArena();
}
inline void RegisterRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.RegisterRequest.username)
}
#if LANG_CXX11
inline void RegisterRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.RegisterRequest.username)
}
#endif
inline void RegisterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.RegisterRequest.username)
}
inline void RegisterRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.RegisterRequest.username)
}
inline ::std::string* RegisterRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.RegisterRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.RegisterRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.RegisterRequest.username)
}

// -------------------------------------------------------------------

// RegisterReply

// -------------------------------------------------------------------

// ChirpRequest

// string username = 1;
inline void ChirpRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.username)
  return username_.GetNoArena();
}
inline void ChirpRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.username)
}
#if LANG_CXX11
inline void ChirpRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.username)
}
#endif
inline void ChirpRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.username)
}
inline void ChirpRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.username)
}
inline ::std::string* ChirpRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.username)
}

// string text = 2;
inline void ChirpRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::text() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.text)
  return text_.GetNoArena();
}
inline void ChirpRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.text)
}
#if LANG_CXX11
inline void ChirpRequest::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.text)
}
#endif
inline void ChirpRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.text)
}
inline void ChirpRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.text)
}
inline ::std::string* ChirpRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_text() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.text)
}

// bytes parent_id = 3;
inline void ChirpRequest::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::parent_id() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.parent_id)
  return parent_id_.GetNoArena();
}
inline void ChirpRequest::set_parent_id(const ::std::string& value) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.parent_id)
}
#if LANG_CXX11
inline void ChirpRequest::set_parent_id(::std::string&& value) {
  
  parent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.parent_id)
}
#endif
inline void ChirpRequest::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.parent_id)
}
inline void ChirpRequest::set_parent_id(const void* value, size_t size) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.parent_id)
}
inline ::std::string* ChirpRequest::mutable_parent_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_parent_id() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.parent_id)
  
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    
  } else {
    
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.parent_id)
}

// -------------------------------------------------------------------

// ChirpReply

// .chirp.Chirp chirp = 1;
inline bool ChirpReply::has_chirp() const {
  return this != internal_default_instance() && chirp_ != NULL;
}
inline void ChirpReply::clear_chirp() {
  if (GetArenaNoVirtual() == NULL && chirp_ != NULL) {
    delete chirp_;
  }
  chirp_ = NULL;
}
inline const ::chirp::Chirp& ChirpReply::_internal_chirp() const {
  return *chirp_;
}
inline const ::chirp::Chirp& ChirpReply::chirp() const {
  const ::chirp::Chirp* p = chirp_;
  // @@protoc_insertion_point(field_get:chirp.ChirpReply.chirp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Chirp*>(
      &::chirp::_Chirp_default_instance_);
}
inline ::chirp::Chirp* ChirpReply::release_chirp() {
  // @@protoc_insertion_point(field_release:chirp.ChirpReply.chirp)
  
  ::chirp::Chirp* temp = chirp_;
  chirp_ = NULL;
  return temp;
}
inline ::chirp::Chirp* ChirpReply::mutable_chirp() {
  
  if (chirp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Chirp>(GetArenaNoVirtual());
    chirp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.ChirpReply.chirp)
  return chirp_;
}
inline void ChirpReply::set_allocated_chirp(::chirp::Chirp* chirp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chirp_;
  }
  if (chirp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chirp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chirp, submessage_arena);
    }
    
  } else {
    
  }
  chirp_ = chirp;
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpReply.chirp)
}

// -------------------------------------------------------------------

// FollowRequest

// string username = 1;
inline void FollowRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.FollowRequest.username)
  return username_.GetNoArena();
}
inline void FollowRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.FollowRequest.username)
}
#if LANG_CXX11
inline void FollowRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.FollowRequest.username)
}
#endif
inline void FollowRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.FollowRequest.username)
}
inline void FollowRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.FollowRequest.username)
}
inline ::std::string* FollowRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.FollowRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.FollowRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.FollowRequest.username)
}

// string to_follow = 2;
inline void FollowRequest::clear_to_follow() {
  to_follow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowRequest::to_follow() const {
  // @@protoc_insertion_point(field_get:chirp.FollowRequest.to_follow)
  return to_follow_.GetNoArena();
}
inline void FollowRequest::set_to_follow(const ::std::string& value) {
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.FollowRequest.to_follow)
}
#if LANG_CXX11
inline void FollowRequest::set_to_follow(::std::string&& value) {
  
  to_follow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.FollowRequest.to_follow)
}
#endif
inline void FollowRequest::set_to_follow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.FollowRequest.to_follow)
}
inline void FollowRequest::set_to_follow(const char* value, size_t size) {
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.FollowRequest.to_follow)
}
inline ::std::string* FollowRequest::mutable_to_follow() {
  
  // @@protoc_insertion_point(field_mutable:chirp.FollowRequest.to_follow)
  return to_follow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowRequest::release_to_follow() {
  // @@protoc_insertion_point(field_release:chirp.FollowRequest.to_follow)
  
  return to_follow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowRequest::set_allocated_to_follow(::std::string* to_follow) {
  if (to_follow != NULL) {
    
  } else {
    
  }
  to_follow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_follow);
  // @@protoc_insertion_point(field_set_allocated:chirp.FollowRequest.to_follow)
}

// -------------------------------------------------------------------

// FollowReply

// -------------------------------------------------------------------

// ReadRequest

// bytes chirp_id = 1;
inline void ReadRequest::clear_chirp_id() {
  chirp_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::chirp_id() const {
  // @@protoc_insertion_point(field_get:chirp.ReadRequest.chirp_id)
  return chirp_id_.GetNoArena();
}
inline void ReadRequest::set_chirp_id(const ::std::string& value) {
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ReadRequest.chirp_id)
}
#if LANG_CXX11
inline void ReadRequest::set_chirp_id(::std::string&& value) {
  
  chirp_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ReadRequest.chirp_id)
}
#endif
inline void ReadRequest::set_chirp_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ReadRequest.chirp_id)
}
inline void ReadRequest::set_chirp_id(const void* value, size_t size) {
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ReadRequest.chirp_id)
}
inline ::std::string* ReadRequest::mutable_chirp_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ReadRequest.chirp_id)
  return chirp_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_chirp_id() {
  // @@protoc_insertion_point(field_release:chirp.ReadRequest.chirp_id)
  
  return chirp_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_chirp_id(::std::string* chirp_id) {
  if (chirp_id != NULL) {
    
  } else {
    
  }
  chirp_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chirp_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.ReadRequest.chirp_id)
}

// -------------------------------------------------------------------

// ReadReply

// repeated .chirp.Chirp chirps = 1;
inline int ReadReply::chirps_size() const {
  return chirps_.size();
}
inline void ReadReply::clear_chirps() {
  chirps_.Clear();
}
inline ::chirp::Chirp* ReadReply::mutable_chirps(int index) {
  // @@protoc_insertion_point(field_mutable:chirp.ReadReply.chirps)
  return chirps_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >*
ReadReply::mutable_chirps() {
  // @@protoc_insertion_point(field_mutable_list:chirp.ReadReply.chirps)
  return &chirps_;
}
inline const ::chirp::Chirp& ReadReply::chirps(int index) const {
  // @@protoc_insertion_point(field_get:chirp.ReadReply.chirps)
  return chirps_.Get(index);
}
inline ::chirp::Chirp* ReadReply::add_chirps() {
  // @@protoc_insertion_point(field_add:chirp.ReadReply.chirps)
  return chirps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >&
ReadReply::chirps() const {
  // @@protoc_insertion_point(field_list:chirp.ReadReply.chirps)
  return chirps_;
}

// -------------------------------------------------------------------

// MonitorRequest

// string username = 1;
inline void MonitorRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MonitorRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.MonitorRequest.username)
  return username_.GetNoArena();
}
inline void MonitorRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.MonitorRequest.username)
}
#if LANG_CXX11
inline void MonitorRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.MonitorRequest.username)
}
#endif
inline void MonitorRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.MonitorRequest.username)
}
inline void MonitorRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.MonitorRequest.username)
}
inline ::std::string* MonitorRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.MonitorRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MonitorRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.MonitorRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MonitorRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.MonitorRequest.username)
}

// -------------------------------------------------------------------

// MonitorReply

// .chirp.Chirp chirp = 1;
inline bool MonitorReply::has_chirp() const {
  return this != internal_default_instance() && chirp_ != NULL;
}
inline void MonitorReply::clear_chirp() {
  if (GetArenaNoVirtual() == NULL && chirp_ != NULL) {
    delete chirp_;
  }
  chirp_ = NULL;
}
inline const ::chirp::Chirp& MonitorReply::_internal_chirp() const {
  return *chirp_;
}
inline const ::chirp::Chirp& MonitorReply::chirp() const {
  const ::chirp::Chirp* p = chirp_;
  // @@protoc_insertion_point(field_get:chirp.MonitorReply.chirp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Chirp*>(
      &::chirp::_Chirp_default_instance_);
}
inline ::chirp::Chirp* MonitorReply::release_chirp() {
  // @@protoc_insertion_point(field_release:chirp.MonitorReply.chirp)
  
  ::chirp::Chirp* temp = chirp_;
  chirp_ = NULL;
  return temp;
}
inline ::chirp::Chirp* MonitorReply::mutable_chirp() {
  
  if (chirp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Chirp>(GetArenaNoVirtual());
    chirp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.MonitorReply.chirp)
  return chirp_;
}
inline void MonitorReply::set_allocated_chirp(::chirp::Chirp* chirp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chirp_;
  }
  if (chirp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chirp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chirp, submessage_arena);
    }
    
  } else {
    
  }
  chirp_ = chirp;
  // @@protoc_insertion_point(field_set_allocated:chirp.MonitorReply.chirp)
}

// -------------------------------------------------------------------

// StreamRequest

// string tag = 1;
inline void StreamRequest::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StreamRequest::tag() const {
  // @@protoc_insertion_point(field_get:chirp.StreamRequest.tag)
  return tag_.GetNoArena();
}
inline void StreamRequest::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.StreamRequest.tag)
}
#if LANG_CXX11
inline void StreamRequest::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.StreamRequest.tag)
}
#endif
inline void StreamRequest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.StreamRequest.tag)
}
inline void StreamRequest::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.StreamRequest.tag)
}
inline ::std::string* StreamRequest::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:chirp.StreamRequest.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamRequest::release_tag() {
  // @@protoc_insertion_point(field_release:chirp.StreamRequest.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamRequest::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:chirp.StreamRequest.tag)
}

// -------------------------------------------------------------------

// StreamReply

// .chirp.Chirp chirp = 1;
inline bool StreamReply::has_chirp() const {
  return this != internal_default_instance() && chirp_ != NULL;
}
inline void StreamReply::clear_chirp() {
  if (GetArenaNoVirtual() == NULL && chirp_ != NULL) {
    delete chirp_;
  }
  chirp_ = NULL;
}
inline const ::chirp::Chirp& StreamReply::_internal_chirp() const {
  return *chirp_;
}
inline const ::chirp::Chirp& StreamReply::chirp() const {
  const ::chirp::Chirp* p = chirp_;
  // @@protoc_insertion_point(field_get:chirp.StreamReply.chirp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Chirp*>(
      &::chirp::_Chirp_default_instance_);
}
inline ::chirp::Chirp* StreamReply::release_chirp() {
  // @@protoc_insertion_point(field_release:chirp.StreamReply.chirp)
  
  ::chirp::Chirp* temp = chirp_;
  chirp_ = NULL;
  return temp;
}
inline ::chirp::Chirp* StreamReply::mutable_chirp() {
  
  if (chirp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Chirp>(GetArenaNoVirtual());
    chirp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.StreamReply.chirp)
  return chirp_;
}
inline void StreamReply::set_allocated_chirp(::chirp::Chirp* chirp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chirp_;
  }
  if (chirp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chirp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chirp, submessage_arena);
    }
    
  } else {
    
  }
  chirp_ = chirp;
  // @@protoc_insertion_point(field_set_allocated:chirp.StreamReply.chirp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chirp

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_service_2eproto
